let {intrinsic} = import "_internal";
let ops = import "std/ops";

sym Iterable_iterator;
pub let Iterable = {
  iterator: Iterable_iterator,
};

sym Iterator_next;
pub let Iterator = {
  next: Iterator_next,
};

pub let generic_equality = {
    [ops.op_eq]: intrinsic("op_eq"),
    [ops.op_ne]: fn (lhs, rhs) => !(lhs == rhs),
};

pub let Null = {
  prototype: {
  }
};

pub let Int = {
  prototype: {
    [ops.op_plus]: intrinsic("int_add"),
    [ops.op_minus]: intrinsic("int_sub"),
    [ops.op_mul]: intrinsic("int_mul"),
    [ops.op_mod]: intrinsic("int_mod"),
    [ops.op_gt]: intrinsic("int_gt"),
    [ops.op_ge]: intrinsic("int_ge"),
    [ops.op_lt]: intrinsic("int_lt"),
    [ops.op_le]: intrinsic("int_le"),
    [ops.op_negate]: intrinsic("int_negate"),
    ..generic_equality,
  }
};

pub let Bool = {
  prototype: {
    [ops.op_not]: fn (self) => if self { false } else { true },
    ..generic_equality,
  }
};

pub let String = {
  prototype: {
    [ops.op_plus]: intrinsic("string_append"),
    ..generic_equality,
  }
};

pub let Symbol = {
  prototype: {}
};

pub let Function = {
  prototype: {}
};

pub let Array = {
  prototype: {
    len: intrinsic("array_len"),
    push: intrinsic("array_push"),
    [Iterable.iterator]: fn (self) => {
      self,
      index: 0,
      [Iterator.next]: fn (self) => do {
        if self.index < self.self.len() {
          let x = self.self[self.index];
          self.index = self.index + 1;
          [x]
        } else {
          []
        }
      }
    },
    ..generic_equality,
  }
};
